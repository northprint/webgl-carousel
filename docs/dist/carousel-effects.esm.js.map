{"version":3,"file":"carousel-effects.esm.js","sources":["../src/effects/BaseEffect.ts","../src/effects/shaderUtils.ts","../src/effects/fade.ts","../src/effects/slide.ts","../src/effects/flip.ts","../src/effects/wave.ts","../src/effects/distortion.ts","../src/effects/dissolve.ts","../src/effects/circle.ts","../src/effects/pixelDissolve.ts","../src/effects/morph.ts","../src/effects/glitch.ts","../src/effects/CustomEffect.ts","../src/effects/index.ts"],"sourcesContent":["import { IEffect } from '../core/EffectManager';\nimport { TriangleMesh } from '../utils/MeshGenerator';\n\nexport abstract class BaseEffect implements IEffect {\n  abstract readonly name: string;\n\n  // Default vertex shader that can be overridden\n  readonly vertexShader: string = `\n    attribute vec2 aPosition;\n    attribute vec2 aTexCoord;\n    \n    varying vec2 vTexCoord;\n    \n    void main() {\n      gl_Position = vec4(aPosition, 0.0, 1.0);\n      vTexCoord = aTexCoord;\n    }\n  `;\n\n  abstract readonly fragmentShader: string;\n\n  abstract getUniforms(progress: number): Record<string, number | number[] | Float32Array>;\n\n  // Optional lifecycle hooks\n  onBeforeRender?(gl: WebGLRenderingContext | WebGL2RenderingContext): void;\n  onAfterRender?(gl: WebGLRenderingContext | WebGL2RenderingContext): void;\n\n  // WebGL 2.0 support\n  get requiresWebGL2(): boolean {\n    return false;\n  }\n\n  // Custom mesh support\n  get requiresCustomMesh(): boolean {\n    return false;\n  }\n\n  getMesh?(): TriangleMesh {\n    throw new Error('getMesh() must be implemented for effects that require custom meshes');\n  }\n\n  // Instance data for instanced rendering\n  getInstanceData?(): { positions: Float32Array; offsets: Float32Array; scales: Float32Array } {\n    return {\n      positions: new Float32Array(0),\n      offsets: new Float32Array(0),\n      scales: new Float32Array(0),\n    };\n  }\n\n  // Transform feedback varyings for WebGL 2.0\n  getTransformFeedbackVaryings?(): string[] {\n    return [];\n  }\n}\n","// Common shader functions and utilities\n\nexport const commonShaderFunctions = `\n  // Custom smooth step function for transitions\n  float customSmoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n  }\n  \n  // Cubic easing function\n  float cubicInOut(float t) {\n    return t < 0.5\n      ? 4.0 * t * t * t\n      : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;\n  }\n  \n  // Linear interpolation\n  vec4 mix4(vec4 a, vec4 b, float t) {\n    return a * (1.0 - t) + b * t;\n  }\n  \n  // 2D rotation matrix\n  mat2 rotate2d(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n  }\n  \n  // Convert normalized coordinates to aspect-corrected coordinates\n  vec2 aspectCorrect(vec2 uv, vec2 resolution) {\n    float aspect = resolution.x / resolution.y;\n    return vec2(uv.x * aspect, uv.y);\n  }\n`;\n\nexport const createFragmentShader = (effectCode: string, includeCommon = true): string => {\n  const common = includeCommon ? commonShaderFunctions : '';\n\n  return `\n    precision mediump float;\n    \n    uniform sampler2D uTexture0;\n    uniform sampler2D uTexture1;\n    uniform float uProgress;\n    uniform vec2 uResolution;\n    uniform vec2 uImageSize0;\n    uniform vec2 uImageSize1;\n    \n    varying vec2 vTexCoord;\n    \n    // Calculate UV coordinates for cover fit\n    vec2 getCoverUV(vec2 uv, vec2 imageSize, vec2 resolution) {\n      // Ensure we have valid sizes\n      if (imageSize.x <= 0.0 || imageSize.y <= 0.0 || resolution.x <= 0.0 || resolution.y <= 0.0) {\n        return uv;\n      }\n      \n      float imageAspect = imageSize.x / imageSize.y;\n      float canvasAspect = resolution.x / resolution.y;\n      \n      vec2 scale = vec2(1.0);\n      if (imageAspect > canvasAspect) {\n        // Image is wider, scale by height\n        scale.x = imageAspect / canvasAspect;\n      } else {\n        // Image is taller, scale by width\n        scale.y = canvasAspect / imageAspect;\n      }\n      \n      // Center the UV coordinates\n      vec2 scaledUV = (uv - 0.5) / scale + 0.5;\n      \n      return scaledUV;\n    }\n    \n    ${common}\n    \n    ${effectCode}\n  `;\n};\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport class FadeEffect extends BaseEffect {\n  readonly name = 'fade';\n\n  readonly fragmentShader = createFragmentShader(`\n    void main() {\n      vec2 uv0 = getCoverUV(vTexCoord, uImageSize0, uResolution);\n      vec2 uv1 = getCoverUV(vTexCoord, uImageSize1, uResolution);\n      \n      vec4 color0 = texture2D(uTexture0, uv0);\n      vec4 color1 = texture2D(uTexture1, uv1);\n      \n      // Simple linear fade\n      gl_FragColor = mix(color0, color1, uProgress);\n    }\n  `);\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    return {\n      uProgress: progress,\n    };\n  }\n}\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport type SlideDirection = 'left' | 'right' | 'up' | 'down';\n\nexport class SlideEffect extends BaseEffect {\n  readonly name: string;\n  private direction: SlideDirection;\n\n  constructor(direction: SlideDirection = 'left') {\n    super();\n    this.direction = direction;\n    this.name = `slide${direction.charAt(0).toUpperCase() + direction.slice(1)}`;\n  }\n\n  readonly fragmentShader = createFragmentShader(`\n    uniform vec2 uDirection;\n    \n    void main() {\n      vec2 uv = vTexCoord;\n      \n      // Calculate offset based on progress\n      vec2 offset = uDirection * uProgress;\n      \n      // Calculate UVs for both images with proper aspect ratio\n      vec2 uv0 = getCoverUV(uv + offset, uImageSize0, uResolution);\n      vec2 uv1 = getCoverUV(uv + offset - uDirection, uImageSize1, uResolution);\n      \n      // Sample textures\n      vec4 color0 = texture2D(uTexture0, uv0);\n      vec4 color1 = texture2D(uTexture1, uv1);\n      \n      // Calculate transition boundary\n      vec2 transitionUV = uv + offset - uDirection;\n      \n      // Create mask based on direction\n      float mask;\n      if (abs(uDirection.x) > 0.5) {\n        // Horizontal slide\n        mask = step(0.0, transitionUV.x) * step(transitionUV.x, 1.0);\n      } else {\n        // Vertical slide\n        mask = step(0.0, transitionUV.y) * step(transitionUV.y, 1.0);\n      }\n      \n      gl_FragColor = mix(color0, color1, mask);\n    }\n  `);\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    let direction: number[] = [0, 0];\n\n    switch (this.direction) {\n      case 'left':\n        direction = [-1, 0];\n        break;\n      case 'right':\n        direction = [1, 0];\n        break;\n      case 'up':\n        direction = [0, 1];\n        break;\n      case 'down':\n        direction = [0, -1];\n        break;\n    }\n\n    return {\n      uProgress: progress,\n      uDirection: direction,\n    };\n  }\n}\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport type FlipAxis = 'horizontal' | 'vertical';\n\nexport class FlipEffect extends BaseEffect {\n  readonly name: string;\n  private axis: FlipAxis;\n\n  constructor(axis: FlipAxis = 'horizontal') {\n    super();\n    this.axis = axis;\n    this.name = `flip${axis.charAt(0).toUpperCase() + axis.slice(1)}`;\n  }\n\n  // カスタム頂点シェーダー - 画像を変形\n  readonly vertexShader = `\n    attribute vec2 aPosition;\n    attribute vec2 aTexCoord;\n    \n    uniform float uProgress;\n    uniform float uAxis;\n    \n    varying vec2 vTexCoord;\n    \n    void main() {\n      vTexCoord = aTexCoord;\n      \n      // 回転角度\n      float angle = uProgress * 3.14159;\n      float scale = abs(cos(angle));\n      \n      vec2 position = aPosition;\n      \n      if (uAxis < 0.5) {\n        // Horizontal flip - X方向のみ縮小\n        position.x *= scale;\n      } else {\n        // Vertical flip - Y方向のみ縮小  \n        position.y *= scale;\n      }\n      \n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n\n  readonly fragmentShader = createFragmentShader(`\n    uniform float uAxis;\n    \n    void main() {\n      vec2 uv = vTexCoord;\n      \n      // 回転角度\n      float angle = uProgress * 3.14159;\n      float cosAngle = cos(angle);\n      \n      // スケール計算（0で完全に消える）\n      float scale = abs(cosAngle);\n      \n      // 表裏の判定\n      bool isBackface = cosAngle < 0.0;\n      \n      vec4 finalColor;\n      \n      if (!isBackface) {\n        // 表面：1枚目の画像\n        vec2 uv0 = getCoverUV(uv, uImageSize0, uResolution);\n        finalColor = texture2D(uTexture0, uv0);\n      } else {\n        // 裏面：2枚目の画像\n        vec2 uv1 = getCoverUV(uv, uImageSize1, uResolution);\n        finalColor = texture2D(uTexture1, uv1);\n      }\n      \n      // 軽いシェーディング効果\n      float shading = 0.7 + 0.3 * scale;\n      finalColor.rgb *= shading;\n      \n      gl_FragColor = finalColor;\n    }\n  `);\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    return {\n      uProgress: progress,\n      uAxis: this.axis === 'vertical' ? 1 : 0,\n    };\n  }\n}\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport interface WaveOptions {\n  amplitude?: number;\n  frequency?: number;\n  speed?: number;\n}\n\nexport class WaveEffect extends BaseEffect {\n  name = 'wave';\n  private amplitude: number;\n  private frequency: number;\n  private speed: number;\n\n  constructor(options: WaveOptions = {}) {\n    super();\n    this.amplitude = options.amplitude ?? 0.1;\n    this.frequency = options.frequency ?? 10.0;\n    this.speed = options.speed ?? 1.0;\n  }\n\n  readonly fragmentShader = createFragmentShader(`\n    uniform float uAmplitude;\n    uniform float uFrequency;\n    uniform float uSpeed;\n    uniform float uTime;\n    \n    void main() {\n      vec2 uv = vTexCoord;\n      \n      // Create wave displacement\n      float wave = sin(uv.y * uFrequency + uTime * uSpeed) * uAmplitude;\n      \n      // Apply wave based on progress\n      float displacement = wave * (1.0 - abs(uProgress - 0.5) * 2.0);\n      \n      // Apply wave displacement then aspect ratio correction\n      vec2 displacedUV0 = vec2(uv.x + displacement * (1.0 - uProgress), uv.y);\n      vec2 displacedUV1 = vec2(uv.x + displacement * uProgress, uv.y);\n      \n      vec2 uv0 = getCoverUV(displacedUV0, uImageSize0, uResolution);\n      vec2 uv1 = getCoverUV(displacedUV1, uImageSize1, uResolution);\n      \n      vec4 color0 = texture2D(uTexture0, uv0);\n      vec4 color1 = texture2D(uTexture1, uv1);\n      \n      // Mix with wave-influenced progress\n      float mixFactor = smoothstep(0.0, 1.0, uProgress + wave * 0.5);\n      \n      gl_FragColor = mix(color0, color1, mixFactor);\n    }\n  `);\n\n  private startTime = Date.now();\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    const time = (Date.now() - this.startTime) / 1000; // Convert to seconds\n\n    return {\n      uProgress: progress,\n      uAmplitude: this.amplitude,\n      uFrequency: this.frequency,\n      uSpeed: this.speed,\n      uTime: time,\n    };\n  }\n\n  onBeforeRender(_gl: WebGLRenderingContext): void {\n    // Reset time on each transition start\n    if (this.lastProgress === 0 && this.lastProgress !== undefined) {\n      this.startTime = Date.now();\n    }\n    this.lastProgress = this.lastProgress ?? 0;\n  }\n\n  private lastProgress?: number;\n}\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport interface DistortionOptions {\n  intensity?: number;\n  radius?: number;\n  spiral?: number;\n}\n\nexport class DistortionEffect extends BaseEffect {\n  name = 'distortion';\n  private intensity: number;\n  private radius: number;\n  private spiral: number;\n\n  constructor(options: DistortionOptions = {}) {\n    super();\n    this.intensity = options.intensity ?? 0.5;\n    this.radius = options.radius ?? 0.8;\n    this.spiral = options.spiral ?? 2.0;\n  }\n\n  readonly fragmentShader = createFragmentShader(`\n    uniform float uIntensity;\n    uniform float uRadius;\n    uniform float uSpiral;\n    \n    vec2 distort(vec2 uv, float progress) {\n      // Center the coordinates\n      vec2 center = vec2(0.5, 0.5);\n      vec2 dir = uv - center;\n      float dist = length(dir);\n      \n      // Create distortion effect\n      float distortionAmount = 0.0;\n      \n      if (dist < uRadius) {\n        // Smooth the edge of distortion\n        float edge = smoothstep(0.0, uRadius, dist);\n        \n        // Calculate rotation based on distance and progress\n        float angle = progress * uSpiral * (1.0 - edge);\n        \n        // Apply rotation\n        float s = sin(angle);\n        float c = cos(angle);\n        dir = vec2(\n          dir.x * c - dir.y * s,\n          dir.x * s + dir.y * c\n        );\n        \n        // Add radial distortion\n        float radialDistort = (1.0 - edge) * progress * uIntensity;\n        dir *= 1.0 + radialDistort;\n      }\n      \n      return center + dir;\n    }\n    \n    void main() {\n      // Create two different distortion phases\n      float phase1 = smoothstep(0.0, 0.5, uProgress);\n      float phase2 = smoothstep(0.5, 1.0, uProgress);\n      \n      // Distort UV coordinates\n      vec2 distortedUV0 = distort(vTexCoord, phase1);\n      vec2 distortedUV1 = distort(vTexCoord, 1.0 - phase2);\n      \n      // Apply aspect ratio correction after distortion\n      vec2 uv0 = getCoverUV(distortedUV0, uImageSize0, uResolution);\n      vec2 uv1 = getCoverUV(distortedUV1, uImageSize1, uResolution);\n      \n      // Sample textures\n      vec4 color0 = texture2D(uTexture0, uv0);\n      vec4 color1 = texture2D(uTexture1, uv1);\n      \n      // Mix based on progress\n      float mixFactor = smoothstep(0.4, 0.6, uProgress);\n      \n      gl_FragColor = mix(color0, color1, mixFactor);\n      \n      // Add vignette effect during transition\n      float vignette = 1.0 - length(vTexCoord - 0.5) * 0.5 * sin(uProgress * 3.14159);\n      gl_FragColor.rgb *= vignette;\n    }\n  `);\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    return {\n      uProgress: progress,\n      uIntensity: this.intensity,\n      uRadius: this.radius,\n      uSpiral: this.spiral,\n    };\n  }\n}\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport interface DissolveOptions {\n  scale?: number;\n  threshold?: number;\n  fadeWidth?: number;\n}\n\nexport class DissolveEffect extends BaseEffect {\n  name = 'dissolve';\n  private scale: number;\n  private threshold: number;\n  private fadeWidth: number;\n\n  constructor(options: DissolveOptions = {}) {\n    super();\n    this.scale = options.scale ?? 10.0;\n    this.threshold = options.threshold ?? 0.5;\n    this.fadeWidth = options.fadeWidth ?? 0.1;\n  }\n\n  readonly fragmentShader = createFragmentShader(`\n    uniform float uScale;\n    uniform float uThreshold;\n    uniform float uFadeWidth;\n    \n    // Simple pseudo-random function\n    float random(vec2 co) {\n      return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    }\n    \n    // Noise function\n    float noise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      \n      float a = random(i);\n      float b = random(i + vec2(1.0, 0.0));\n      float c = random(i + vec2(0.0, 1.0));\n      float d = random(i + vec2(1.0, 1.0));\n      \n      vec2 u = f * f * (3.0 - 2.0 * f);\n      \n      return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n    }\n    \n    void main() {\n      // Apply aspect ratio correction\n      vec2 uv0 = getCoverUV(vTexCoord, uImageSize0, uResolution);\n      vec2 uv1 = getCoverUV(vTexCoord, uImageSize1, uResolution);\n      \n      // Generate noise for dissolve effect\n      float n = noise(vTexCoord * uScale);\n      \n      // Add some variation with multiple octaves\n      n += noise(vTexCoord * uScale * 2.0) * 0.5;\n      n += noise(vTexCoord * uScale * 4.0) * 0.25;\n      n = n / 1.75; // Normalize\n      \n      // Calculate dissolve threshold\n      float threshold = uProgress * (1.0 + uFadeWidth * 2.0) - uFadeWidth;\n      \n      // Create smooth transition\n      float alpha = smoothstep(threshold - uFadeWidth, threshold + uFadeWidth, n);\n      \n      // Sample textures\n      vec4 color0 = texture2D(uTexture0, uv0);\n      vec4 color1 = texture2D(uTexture1, uv1);\n      \n      // Mix colors based on dissolve\n      gl_FragColor = mix(color1, color0, alpha);\n    }\n  `);\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    return {\n      uProgress: progress,\n      uScale: this.scale,\n      uThreshold: this.threshold,\n      uFadeWidth: this.fadeWidth,\n    };\n  }\n}\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport interface CircleOptions {\n  centerX?: number;\n  centerY?: number;\n  feather?: number;\n  scale?: number;\n}\n\nexport class CircleEffect extends BaseEffect {\n  name = 'circle';\n  private centerX: number;\n  private centerY: number;\n  private feather: number;\n  private scale: number;\n\n  constructor(options: CircleOptions = {}) {\n    super();\n    this.centerX = options.centerX ?? 0.5;\n    this.centerY = options.centerY ?? 0.5;\n    this.feather = options.feather ?? 0.1;\n    this.scale = options.scale ?? 1.0;\n  }\n\n  readonly fragmentShader = createFragmentShader(`\n    uniform vec2 uCenter;\n    uniform float uFeather;\n    uniform float uScale;\n    \n    void main() {\n      // Apply aspect ratio correction\n      vec2 uv0 = getCoverUV(vTexCoord, uImageSize0, uResolution);\n      vec2 uv1 = getCoverUV(vTexCoord, uImageSize1, uResolution);\n      \n      // Calculate distance from center\n      vec2 center = uCenter;\n      vec2 pos = vTexCoord - center;\n      \n      // Correct for aspect ratio\n      float aspect = uResolution.x / uResolution.y;\n      pos.x *= aspect;\n      \n      float dist = length(pos);\n      \n      // Calculate circle radius based on progress\n      float radius = uProgress * uScale * sqrt(2.0); // sqrt(2) to cover corners\n      \n      // Create smooth edge\n      float alpha = smoothstep(radius - uFeather, radius + uFeather, dist);\n      \n      // Sample textures\n      vec4 color0 = texture2D(uTexture0, uv0);\n      vec4 color1 = texture2D(uTexture1, uv1);\n      \n      // Mix based on circle mask\n      gl_FragColor = mix(color1, color0, alpha);\n    }\n  `);\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    return {\n      uProgress: progress,\n      uCenter: [this.centerX, this.centerY],\n      uFeather: this.feather,\n      uScale: this.scale,\n    };\n  }\n}\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport interface PixelDissolveOptions {\n  pixelSize?: number;\n  stagger?: number;\n}\n\nexport class PixelDissolveEffect extends BaseEffect {\n  name = 'pixelDissolve';\n  private pixelSize: number;\n  private stagger: number;\n\n  constructor(options: PixelDissolveOptions = {}) {\n    super();\n    this.pixelSize = options.pixelSize ?? 20.0;\n    this.stagger = options.stagger ?? 0.3;\n  }\n\n  readonly fragmentShader = createFragmentShader(`\n    uniform float uPixelSize;\n    uniform float uStagger;\n    \n    // Simple pseudo-random function\n    float random(vec2 co) {\n      return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    }\n    \n    void main() {\n      // Apply aspect ratio correction\n      vec2 uv0 = getCoverUV(vTexCoord, uImageSize0, uResolution);\n      vec2 uv1 = getCoverUV(vTexCoord, uImageSize1, uResolution);\n      \n      // Calculate pixel grid coordinates\n      vec2 pixelCoord = floor(vTexCoord * uResolution / uPixelSize);\n      \n      // Generate random value per pixel\n      float pixelRandom = random(pixelCoord);\n      \n      // Add some variation based on position\n      float positionBias = (pixelCoord.x + pixelCoord.y) / (uResolution.x / uPixelSize + uResolution.y / uPixelSize);\n      pixelRandom = mix(pixelRandom, positionBias, uStagger);\n      \n      // Calculate transition threshold\n      float threshold = uProgress;\n      \n      // Determine pixel visibility with hard edge\n      float alpha = step(pixelRandom, threshold);\n      \n      // Sample textures\n      vec4 color0 = texture2D(uTexture0, uv0);\n      vec4 color1 = texture2D(uTexture1, uv1);\n      \n      // Mix colors based on pixel visibility\n      gl_FragColor = mix(color0, color1, alpha);\n    }\n  `);\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    return {\n      uProgress: progress,\n      uPixelSize: this.pixelSize,\n      uStagger: this.stagger,\n    };\n  }\n}\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport interface MorphOptions {\n  gridSize?: number;\n  morphIntensity?: number;\n  twistAmount?: number;\n  waveFrequency?: number;\n}\n\nexport class MorphEffect extends BaseEffect {\n  name = 'morph';\n  private gridSize: number;\n  private morphIntensity: number;\n  private twistAmount: number;\n  private waveFrequency: number;\n\n  constructor(options: MorphOptions = {}) {\n    super();\n    this.gridSize = options.gridSize ?? 50.0;\n    this.morphIntensity = options.morphIntensity ?? 0.3;\n    this.twistAmount = options.twistAmount ?? 2.0;\n    this.waveFrequency = options.waveFrequency ?? 3.0;\n  }\n\n  // カスタム頂点シェーダー - 頂点を動的に変形\n  readonly vertexShader = `\n    attribute vec2 aPosition;\n    attribute vec2 aTexCoord;\n    \n    uniform float uProgress;\n    uniform float uMorphIntensity;\n    uniform float uTwistAmount;\n    uniform float uWaveFrequency;\n    uniform vec2 uResolution;\n    \n    varying vec2 vTexCoord;\n    varying float vMorphAmount;\n    \n    void main() {\n      vTexCoord = aTexCoord;\n      \n      // 中心からの距離を計算\n      vec2 center = vec2(0.5, 0.5);\n      vec2 toCenter = aTexCoord - center;\n      float dist = length(toCenter);\n      \n      // プログレスに基づくモーフ量を計算\n      float morphProgress = smoothstep(0.0, 1.0, uProgress);\n      float morphAmount = sin(morphProgress * 3.14159);\n      vMorphAmount = morphAmount;\n      \n      // 頂点の変位を計算\n      vec2 position = aPosition;\n      \n      // ツイスト効果\n      float angle = atan(toCenter.y, toCenter.x);\n      float twist = sin(angle * uWaveFrequency + morphProgress * uTwistAmount) * morphAmount;\n      position.x += twist * toCenter.y * uMorphIntensity;\n      position.y -= twist * toCenter.x * uMorphIntensity;\n      \n      // 波形効果\n      float wave = sin(dist * 10.0 - morphProgress * 5.0) * morphAmount;\n      position += normalize(toCenter) * wave * uMorphIntensity * 0.5;\n      \n      // Z軸の変位（3D効果）\n      float z = sin(dist * 8.0 + morphProgress * 4.0) * morphAmount * 0.3;\n      \n      gl_Position = vec4(position, z, 1.0);\n    }\n  `;\n\n  readonly fragmentShader = createFragmentShader(`\n    uniform float uGridSize;\n    varying float vMorphAmount;\n    \n    void main() {\n      vec2 uv0 = getCoverUV(vTexCoord, uImageSize0, uResolution);\n      vec2 uv1 = getCoverUV(vTexCoord, uImageSize1, uResolution);\n      \n      // グリッドベースの歪み\n      vec2 gridUV = vTexCoord * uGridSize;\n      vec2 gridPos = floor(gridUV);\n      vec2 gridFract = fract(gridUV);\n      \n      // モーフ量に基づく歪み\n      vec2 distortion = sin(gridPos * 0.1 + vMorphAmount * 3.14159) * 0.02 * vMorphAmount;\n      \n      vec2 distortedUV0 = uv0 + distortion;\n      vec2 distortedUV1 = uv1 - distortion;\n      \n      vec4 color0 = texture2D(uTexture0, distortedUV0);\n      vec4 color1 = texture2D(uTexture1, distortedUV1);\n      \n      // エッジ効果\n      float edge = 1.0 - smoothstep(0.4, 0.5, abs(gridFract.x - 0.5)) * \n                         smoothstep(0.4, 0.5, abs(gridFract.y - 0.5));\n      edge *= vMorphAmount;\n      \n      // カラーミックス\n      float mixFactor = smoothstep(0.3, 0.7, uProgress);\n      vec4 finalColor = mix(color0, color1, mixFactor);\n      \n      // エッジハイライト\n      finalColor.rgb += vec3(edge * 0.2);\n      \n      // 色収差効果\n      vec2 aberration = distortion * 2.0;\n      finalColor.r = mix(\n        texture2D(uTexture0, distortedUV0 + aberration).r,\n        texture2D(uTexture1, distortedUV1 + aberration).r,\n        mixFactor\n      );\n      finalColor.b = mix(\n        texture2D(uTexture0, distortedUV0 - aberration).b,\n        texture2D(uTexture1, distortedUV1 - aberration).b,\n        mixFactor\n      );\n      \n      gl_FragColor = finalColor;\n    }\n  `);\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    return {\n      uProgress: progress,\n      uGridSize: this.gridSize,\n      uMorphIntensity: this.morphIntensity,\n      uTwistAmount: this.twistAmount,\n      uWaveFrequency: this.waveFrequency,\n    };\n  }\n}\n","import { BaseEffect } from './BaseEffect';\nimport { createFragmentShader } from './shaderUtils';\n\nexport interface GlitchOptions {\n  intensity?: number;\n  sliceCount?: number;\n  colorShift?: number;\n  noiseAmount?: number;\n}\n\nexport class GlitchEffect extends BaseEffect {\n  name = 'glitch';\n  private intensity: number;\n  private sliceCount: number;\n  private colorShift: number;\n  private noiseAmount: number;\n  private startTime: number;\n\n  constructor(options: GlitchOptions = {}) {\n    super();\n    this.intensity = options.intensity ?? 0.5;\n    this.sliceCount = options.sliceCount ?? 15.0;\n    this.colorShift = options.colorShift ?? 0.03;\n    this.noiseAmount = options.noiseAmount ?? 0.1;\n    this.startTime = Date.now();\n  }\n\n  readonly fragmentShader = createFragmentShader(`\n    uniform float uIntensity;\n    uniform float uSliceCount;\n    uniform float uColorShift;\n    uniform float uNoiseAmount;\n    uniform float uTime;\n    \n    // 擬似乱数生成\n    float random(vec2 co) {\n      return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    }\n    \n    // ノイズ関数\n    float noise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      \n      float a = random(i);\n      float b = random(i + vec2(1.0, 0.0));\n      float c = random(i + vec2(0.0, 1.0));\n      float d = random(i + vec2(1.0, 1.0));\n      \n      vec2 u = f * f * (3.0 - 2.0 * f);\n      \n      return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n    }\n    \n    void main() {\n      vec2 uv = vTexCoord;\n      \n      // グリッチ強度の計算（時間ベース）\n      float glitchStrength = step(0.5, sin(uTime * 20.0)) * uIntensity;\n      glitchStrength *= step(0.8, random(vec2(uTime * 10.0, 0.0)));\n      \n      // プログレスに基づくグリッチの増減\n      float progressGlitch = sin(uProgress * 3.14159);\n      glitchStrength *= progressGlitch;\n      \n      // 水平スライスの計算\n      float slice = floor(uv.y * uSliceCount);\n      float sliceOffset = random(vec2(slice, uTime)) * 2.0 - 1.0;\n      sliceOffset *= step(0.7, random(vec2(slice * 2.0, uTime * 10.0))) * glitchStrength;\n      \n      // UV座標の歪み\n      vec2 distortedUV = uv;\n      distortedUV.x += sliceOffset * 0.1;\n      \n      // ブロックノイズ\n      vec2 blockSize = vec2(0.05, 0.03);\n      vec2 blockCoord = floor(uv / blockSize) * blockSize;\n      float blockNoise = step(0.9, random(blockCoord + vec2(uTime * 5.0))) * glitchStrength;\n      distortedUV += blockNoise * (random(blockCoord * 2.0) - 0.5) * uNoiseAmount;\n      \n      // アスペクト比補正を適用\n      vec2 uv0 = getCoverUV(distortedUV, uImageSize0, uResolution);\n      vec2 uv1 = getCoverUV(distortedUV, uImageSize1, uResolution);\n      \n      // テクスチャサンプリング\n      vec4 color0 = texture2D(uTexture0, uv0);\n      vec4 color1 = texture2D(uTexture1, uv1);\n      \n      // RGB分離（グリッチ効果）\n      vec4 color0Shift = vec4(\n        texture2D(uTexture0, getCoverUV(distortedUV + vec2(uColorShift * glitchStrength, 0.0), uImageSize0, uResolution)).r,\n        color0.g,\n        texture2D(uTexture0, getCoverUV(distortedUV - vec2(uColorShift * glitchStrength, 0.0), uImageSize0, uResolution)).b,\n        color0.a\n      );\n      \n      vec4 color1Shift = vec4(\n        texture2D(uTexture1, getCoverUV(distortedUV + vec2(uColorShift * glitchStrength, 0.0), uImageSize1, uResolution)).r,\n        color1.g,\n        texture2D(uTexture1, getCoverUV(distortedUV - vec2(uColorShift * glitchStrength, 0.0), uImageSize1, uResolution)).b,\n        color1.a\n      );\n      \n      // カラーミックス\n      float mixFactor = smoothstep(0.3, 0.7, uProgress);\n      vec4 finalColor = mix(color0Shift, color1Shift, mixFactor);\n      \n      // デジタルノイズ\n      float digitalNoise = random(uv + vec2(uTime * 100.0)) * glitchStrength * 0.1;\n      finalColor.rgb += vec3(digitalNoise);\n      \n      // カラー反転（ランダム）\n      float invertChance = step(0.95, random(vec2(uTime * 30.0))) * glitchStrength;\n      finalColor.rgb = mix(finalColor.rgb, 1.0 - finalColor.rgb, invertChance);\n      \n      // スキャンライン\n      float scanline = sin(uv.y * 800.0) * 0.04 * glitchStrength;\n      finalColor.rgb -= scanline;\n      \n      gl_FragColor = finalColor;\n    }\n  `);\n\n  getUniforms(progress: number): Record<string, number | number[]> {\n    const time = (Date.now() - this.startTime) / 1000;\n    return {\n      uProgress: progress,\n      uIntensity: this.intensity,\n      uSliceCount: this.sliceCount,\n      uColorShift: this.colorShift,\n      uNoiseAmount: this.noiseAmount,\n      uTime: time,\n    };\n  }\n}\n","import { BaseEffect } from './BaseEffect';\nimport { TriangleMesh } from '../utils/MeshGenerator';\n\nexport interface CustomEffectOptions {\n  name: string;\n  vertexShader: string;\n  fragmentShader: string;\n  uniforms?: () => Record<string, number | number[] | Float32Array>;\n  requiresWebGL2?: boolean;\n  requiresCustomMesh?: boolean;\n  getMesh?: () => { positions: Float32Array; indices: Uint16Array };\n  getInstanceData?: () => Float32Array | null;\n  getTransformFeedbackVaryings?: () => string[];\n}\n\n/**\n * Custom effect that allows loading external shaders\n */\nexport class CustomEffect extends BaseEffect {\n  name: string;\n  vertexShader: string;\n  fragmentShader: string;\n  private uniformsGetter?: () => Record<string, number | number[] | Float32Array>;\n  private _requiresWebGL2: boolean;\n  private _requiresCustomMesh: boolean;\n  private _getMesh?: () => { positions: Float32Array; indices: Uint16Array };\n  private _getInstanceData?: () => Float32Array | null;\n  private _getTransformFeedbackVaryings?: () => string[];\n\n  constructor(options: CustomEffectOptions) {\n    super();\n    this.name = options.name;\n    this.vertexShader = options.vertexShader;\n    this.fragmentShader = options.fragmentShader;\n    this.uniformsGetter = options.uniforms;\n    this._requiresWebGL2 = options.requiresWebGL2 ?? false;\n    this._requiresCustomMesh = options.requiresCustomMesh ?? false;\n    this._getMesh = options.getMesh;\n    this._getInstanceData = options.getInstanceData;\n    this._getTransformFeedbackVaryings = options.getTransformFeedbackVaryings;\n  }\n\n  getUniforms(progress: number): Record<string, number | number[] | Float32Array> {\n    const baseUniforms = {\n      uProgress: progress,\n    };\n\n    if (this.uniformsGetter) {\n      return { ...baseUniforms, ...this.uniformsGetter() };\n    }\n\n    return baseUniforms;\n  }\n\n  get requiresWebGL2(): boolean {\n    return this._requiresWebGL2;\n  }\n\n  get requiresCustomMesh(): boolean {\n    return this._requiresCustomMesh;\n  }\n\n  getMesh(): TriangleMesh {\n    if (this._getMesh) {\n      const mesh = this._getMesh();\n      return {\n        positions: mesh.positions,\n        indices: mesh.indices,\n        texCoords: new Float32Array(0), // Default empty\n        normals: new Float32Array(0), // Default empty\n        triangles: [],\n      };\n    }\n    throw new Error('getMesh() not implemented for this custom effect');\n  }\n\n  getInstanceData(): { positions: Float32Array; offsets: Float32Array; scales: Float32Array } {\n    if (this._getInstanceData) {\n      const data = this._getInstanceData();\n      if (data) {\n        // Convert Float32Array to the expected format\n        return {\n          positions: data,\n          offsets: new Float32Array(0),\n          scales: new Float32Array(0),\n        };\n      }\n    }\n    // Return empty data instead of null to match BaseEffect\n    return {\n      positions: new Float32Array(0),\n      offsets: new Float32Array(0),\n      scales: new Float32Array(0),\n    };\n  }\n\n  getTransformFeedbackVaryings(): string[] {\n    if (this._getTransformFeedbackVaryings) {\n      return this._getTransformFeedbackVaryings();\n    }\n    return [];\n  }\n}\n\n/**\n * Helper function to create a custom effect from external shader files\n */\nexport async function createCustomEffectFromFiles(\n  name: string,\n  vertexShaderUrl: string,\n  fragmentShaderUrl: string,\n  options?: Partial<CustomEffectOptions>,\n): Promise<CustomEffect> {\n  const [vertexShader, fragmentShader] = await Promise.all([\n    fetch(vertexShaderUrl).then((r) => r.text()),\n    fetch(fragmentShaderUrl).then((r) => r.text()),\n  ]);\n\n  return new CustomEffect({\n    name,\n    vertexShader,\n    fragmentShader,\n    ...options,\n  });\n}\n\n/**\n * Helper function to create a custom effect from shader strings\n */\nexport function createCustomEffect(\n  name: string,\n  vertexShader: string | undefined,\n  fragmentShader: string,\n  options?: Partial<CustomEffectOptions>,\n): CustomEffect {\n  // Use default vertex shader if not provided\n  const defaultVertexShader = `\n    attribute vec2 aPosition;\n    attribute vec2 aTexCoord;\n    \n    varying vec2 vTexCoord;\n    \n    void main() {\n      gl_Position = vec4(aPosition, 0.0, 1.0);\n      vTexCoord = aTexCoord;\n    }\n  `;\n\n  return new CustomEffect({\n    name,\n    vertexShader: vertexShader || defaultVertexShader,\n    fragmentShader,\n    ...options,\n  });\n}\n","// Re-export all effects\nexport { BaseEffect } from './BaseEffect';\nexport { createFragmentShader, commonShaderFunctions } from './shaderUtils';\n\n// Effect classes\nexport { FadeEffect } from './fade';\nexport { SlideEffect, type SlideDirection } from './slide';\nexport { FlipEffect, type FlipAxis } from './flip';\nexport { WaveEffect, type WaveOptions } from './wave';\nexport { DistortionEffect, type DistortionOptions } from './distortion';\nexport { DissolveEffect, type DissolveOptions } from './dissolve';\nexport { CircleEffect, type CircleOptions } from './circle';\nexport { PixelDissolveEffect, type PixelDissolveOptions } from './pixelDissolve';\nexport { MorphEffect, type MorphOptions } from './morph';\nexport { GlitchEffect, type GlitchOptions } from './glitch';\nexport {\n  CustomEffect,\n  createCustomEffect,\n  createCustomEffectFromFiles,\n  type CustomEffectOptions,\n} from './CustomEffect';\n\n// Import classes for creating instances\nimport { FadeEffect } from './fade';\nimport { SlideEffect } from './slide';\nimport { FlipEffect } from './flip';\nimport { WaveEffect } from './wave';\nimport { DistortionEffect } from './distortion';\nimport { DissolveEffect } from './dissolve';\nimport { CircleEffect } from './circle';\nimport { PixelDissolveEffect } from './pixelDissolve';\nimport { MorphEffect } from './morph';\nimport { GlitchEffect } from './glitch';\n\n// Create and export singleton instances\nexport const fadeEffect = new FadeEffect();\nexport const slideLeftEffect = new SlideEffect('left');\nexport const slideRightEffect = new SlideEffect('right');\nexport const slideUpEffect = new SlideEffect('up');\nexport const slideDownEffect = new SlideEffect('down');\nexport const flipHorizontalEffect = new FlipEffect('horizontal');\nexport const flipVerticalEffect = new FlipEffect('vertical');\nexport const waveEffect = new WaveEffect();\nexport const gentleWaveEffect = new WaveEffect({ amplitude: 0.05, frequency: 5.0, speed: 0.5 });\nexport const intenseWaveEffect = new WaveEffect({ amplitude: 0.2, frequency: 15.0, speed: 2.0 });\nexport const distortionEffect = new DistortionEffect();\nexport const subtleDistortionEffect = new DistortionEffect({\n  intensity: 0.3,\n  radius: 0.6,\n  spiral: 1.0,\n});\nexport const extremeDistortionEffect = new DistortionEffect({\n  intensity: 1.0,\n  radius: 1.0,\n  spiral: 4.0,\n});\nexport const dissolveEffect = new DissolveEffect();\nexport const smoothDissolveEffect = new DissolveEffect({\n  scale: 5.0,\n  threshold: 0.5,\n  fadeWidth: 0.2,\n});\nexport const pixelDissolveEffect = new PixelDissolveEffect();\nexport const largePixelDissolveEffect = new PixelDissolveEffect({\n  pixelSize: 40.0,\n  stagger: 0.2,\n});\nexport const smallPixelDissolveEffect = new PixelDissolveEffect({\n  pixelSize: 10.0,\n  stagger: 0.4,\n});\nexport const circleEffect = new CircleEffect();\nexport const circleFromCenterEffect = new CircleEffect({\n  centerX: 0.5,\n  centerY: 0.5,\n  feather: 0.05,\n  scale: 1.2,\n});\nexport const circleFromCornerEffect = new CircleEffect({\n  centerX: 0.0,\n  centerY: 0.0,\n  feather: 0.1,\n  scale: 1.5,\n});\nexport const morphEffect = new MorphEffect();\nexport const intenseMorphEffect = new MorphEffect({\n  gridSize: 100.0,\n  morphIntensity: 0.5,\n  twistAmount: 4.0,\n  waveFrequency: 5.0,\n});\nexport const glitchEffect = new GlitchEffect();\nexport const intenseGlitchEffect = new GlitchEffect({\n  intensity: 0.8,\n  sliceCount: 25.0,\n  colorShift: 0.05,\n  noiseAmount: 0.2,\n});\nexport const subtleGlitchEffect = new GlitchEffect({\n  intensity: 0.3,\n  sliceCount: 10.0,\n  colorShift: 0.02,\n  noiseAmount: 0.05,\n});\n\n// Set unique names for effect variants\ngentleWaveEffect.name = 'gentleWave';\nintenseWaveEffect.name = 'intenseWave';\nsubtleDistortionEffect.name = 'subtleDistortion';\nextremeDistortionEffect.name = 'extremeDistortion';\npixelDissolveEffect.name = 'pixelDissolve';\nsmoothDissolveEffect.name = 'smoothDissolve';\ncircleFromCenterEffect.name = 'circleFromCenter';\ncircleFromCornerEffect.name = 'circleFromCorner';\nlargePixelDissolveEffect.name = 'largePixelDissolve';\nsmallPixelDissolveEffect.name = 'smallPixelDissolve';\nintenseMorphEffect.name = 'intenseMorph';\nintenseGlitchEffect.name = 'intenseGlitch';\nsubtleGlitchEffect.name = 'subtleGlitch';\n\n// Collection of all default effects\nexport function getDefaultEffects() {\n  return [\n    fadeEffect,\n    slideLeftEffect,\n    slideRightEffect,\n    slideUpEffect,\n    slideDownEffect,\n    flipHorizontalEffect,\n    flipVerticalEffect,\n    waveEffect,\n    gentleWaveEffect,\n    intenseWaveEffect,\n    distortionEffect,\n    subtleDistortionEffect,\n    extremeDistortionEffect,\n    dissolveEffect,\n    pixelDissolveEffect,\n    largePixelDissolveEffect,\n    smallPixelDissolveEffect,\n    smoothDissolveEffect,\n    circleEffect,\n    circleFromCenterEffect,\n    circleFromCornerEffect,\n    morphEffect,\n    intenseMorphEffect,\n    glitchEffect,\n    intenseGlitchEffect,\n    subtleGlitchEffect,\n  ];\n}\n\nimport type { EffectManager } from '../core/EffectManager';\n\n// Helper to register all default effects\nexport function registerDefaultEffects(manager: EffectManager): void {\n  getDefaultEffects().forEach((effect) => manager.register(effect));\n}\n"],"names":[],"mappings":"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"}